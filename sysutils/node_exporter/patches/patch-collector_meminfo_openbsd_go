$OpenBSD$
--- collector/meminfo_openbsd.go.orig	Fri Sep  2 23:08:18 2016
+++ collector/meminfo_openbsd.go	Fri Sep  2 23:08:54 2016
@@ -0,0 +1,85 @@
+// +build !nomeminfo
+
+package collector
+
+import (
+	"unsafe"
+
+	"github.com/prometheus/client_golang/prometheus"
+	"github.com/prometheus/common/log"
+)
+
+/*
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <sys/sysctl.h>
+*/
+import "C"
+
+const (
+	memInfoSubsystem = "memory"
+)
+
+type meminfoCollector struct {
+	
+	metrics map[string]prometheus.Gauge
+}
+
+func init() {
+	Factories["meminfo"] = NewMeminfoCollector
+}
+
+// Takes a prometheus registry and returns a new Collector exposing
+// Memory stats.
+func NewMeminfoCollector() (Collector, error) {
+	return &meminfoCollector{
+		metrics: map[string]prometheus.Gauge{},
+	}, nil
+}
+
+func (c *meminfoCollector) Update(ch chan<- prometheus.Metric) (err error) {
+	var uvmexp C.struct_uvmexp
+	var bcachestats C.struct_bcachestats
+	var pages map[string]int64
+	
+	pages = make(map[string]int64)
+
+	err = Sysctl([]C.int{ C.CTL_VFS, C.VFS_GENERIC, C.VFS_BCACHESTAT },
+		unsafe.Pointer(&bcachestats), unsafe.Sizeof(bcachestats))
+	if err != nil {
+		return err
+	}
+
+	err = Sysctl([]C.int{ C.CTL_VM, C.VM_UVMEXP },
+		unsafe.Pointer(&uvmexp), unsafe.Sizeof(uvmexp))
+	if err != nil {
+		return err
+	}
+
+	pages["active"] = int64(uvmexp.active);
+	pages["inactive"] = int64(uvmexp.inactive);
+	pages["wire"] = int64(uvmexp.wired);
+	pages["swappgsout"] = int64(uvmexp.paging);
+	pages["MemFree"] = int64(uvmexp.free);
+	pages["MemTotal"] = int64(uvmexp.npages);
+	pages["Cached"] = 0;
+	pages["Buffers"] = int64(bcachestats.numbufpages);
+
+	size := uvmexp.pagesize;
+
+	log.Debugf("Set node_mem: %#v", pages)
+	for k, v := range pages {
+		if _, ok := c.metrics[k]; !ok {
+			c.metrics[k] = prometheus.NewGauge(prometheus.GaugeOpts{
+				Namespace: Namespace,
+				Subsystem: memInfoSubsystem,
+				Name:      k,
+				Help:      k + " from uvmexp sysctl.",
+			})
+		}
+		// Convert metrics to kB (same as Linux meminfo).
+		c.metrics[k].Set(float64(v) * float64(size))
+		c.metrics[k].Collect(ch)
+	}
+	return err
+}
